<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clip Flow</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; font-family: -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { display: flex; flex-direction: column; height: 100%; box-sizing: border-box; }
    .top { padding: 10px; border-bottom: 1px solid #e5e5e5; display: flex; gap: 8px; align-items: center; }
    .top input { flex: 1; padding: 6px 8px; font-size: 14px; }
    .content { flex: 1; overflow: auto; padding: 8px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 6px 8px; font-size: 13px; }
    tr:hover { background: #f7f7f7; }
    tr.selected { background: #e3f2fd; }

    .context-menu { position: absolute; background: #fff; border: 1px solid #ccc; border-radius: 4px; padding: 4px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; display: none; }
    .context-menu-item { padding: 6px 16px; cursor: pointer; font-size: 13px; }
    .context-menu-item:hover { background: #f5f5f5; }
    .context-menu-item.danger:hover { background: #ffebee; color: #d32f2f; }

    .buttons { padding: 8px; border-top: 1px solid #e5e5e5; display: flex; gap: 8px; justify-content: space-between; }
    button { padding: 6px 10px; font-size: 13px; cursor: pointer; }
    .right { display: flex; gap: 8px; }

    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; }
    .modal .card { width: 90%; max-width: 600px; background: #fff; border-radius: 6px; box-shadow: 0 8px 24px rgba(0,0,0,0.2); display: flex; flex-direction: column; max-height: 80vh; }
    .modal .head { padding: 10px; border-bottom: 1px solid #e5e5e5; font-weight: 600; }
    .modal .body { padding: 10px; overflow: auto; white-space: pre-wrap; font-family: Consolas, Menlo, monospace; font-size: 12px; }
    .modal .foot { padding: 8px; border-top: 1px solid #e5e5e5; display: flex; justify-content: flex-end; gap: 8px; }
    
    .settings-body { font-family: -apple-system, Segoe UI, Roboto, Arial, sans-serif; white-space: normal; }
    .settings-group { margin-bottom: 20px; }
    .settings-group h3 { margin: 0 0 8px 0; font-size: 14px; color: #333; }
    .settings-group .description { font-size: 12px; color: #666; margin-bottom: 12px; }
    .setting-item { margin-bottom: 16px; }
    .setting-label { display: block; font-size: 13px; font-weight: 500; margin-bottom: 4px; }
    .setting-description { font-size: 11px; color: #666; margin-bottom: 6px; }
    .setting-input { width: 100%; padding: 6px 8px; font-size: 13px; border: 1px solid #ddd; border-radius: 3px; }
    .setting-input[type="checkbox"] { width: auto; }
    .setting-input[type="range"] { width: 100%; }
    .range-display { font-size: 12px; color: #666; margin-top: 2px; }
  </style>
  <script>
    let state = { items: [], selected: -1 };
    let contextMenu = null;

    function updateHistory(items) {
      state.items = items || [];
      const tbody = document.getElementById('tbody');
      tbody.innerHTML = '';
      state.items.forEach((item, i) => {
        const tr = document.createElement('tr');
        tr.dataset.index = i;
        if (i === state.selected) tr.classList.add('selected');
        const num = document.createElement('td'); num.textContent = (i + 1).toString(); num.style.width = '36px';
        const txt = document.createElement('td');
        const preview = item.replace(/\n|\r/g, ' ');
        txt.textContent = preview.length > 50 ? (preview.slice(0,47) + '...') : preview;
        tr.appendChild(num); tr.appendChild(txt);
        tr.addEventListener('click', () => selectRow(i));
        tr.addEventListener('dblclick', () => onCopy());
        tr.addEventListener('contextmenu', (e) => showContextMenu(e, i));
        tbody.appendChild(tr);
      });
      if (state.items.length && state.selected === -1) {
        selectRow(0);
      }
    }

    function selectRow(i) {
      state.selected = i;
      const rows = [...document.querySelectorAll('#tbody tr')];
      rows.forEach(r => r.classList.remove('selected'));
      const row = rows[i]; if (row) row.classList.add('selected');
    }

    function onSearch(e) {
      const val = typeof e === 'string' ? e : e.target.value;
      if (window.pywebview && pywebview.api) pywebview.api.on_search(val);
    }

    function onCopy() {
      if (state.selected < 0) { showMessage({message: 'Please select an item to copy.', type: 'warning'}); return; }
      if (window.pywebview && pywebview.api) pywebview.api.on_copy(state.selected);
    }

    function onView() {
      if (state.selected < 0) { showMessage({message: 'Please select an item to view.', type: 'warning'}); return; }
      document.getElementById('modal-text').textContent = state.items[state.selected] || '';
      document.getElementById('modal').style.display = 'flex';
    }

    function onClear() {
      if (!confirm('Are you sure you want to clear all clipboard history?')) return;
      if (window.pywebview && pywebview.api) pywebview.api.on_clear();
    }

    function onCloseModal() { document.getElementById('modal').style.display = 'none'; }

    function onSettings() {
      loadSettings();
    }

    async function loadSettings() {
      if (!window.pywebview || !pywebview.api) {
        showMessage({message: 'Settings API not available', type: 'error'});
        return;
      }

      try {
        const metadata = await pywebview.api.get_settings_metadata();
        const values = await pywebview.api.get_settings_values();
        showSettingsModal(metadata, values);
      } catch (e) {
        showMessage({message: 'Failed to load settings: ' + e.message, type: 'error'});
      }
    }

    function showSettingsModal(metadata, values) {
      const modal = document.getElementById('modal');
      const head = modal.querySelector('.head');
      const body = modal.querySelector('.body');
      const foot = modal.querySelector('.foot');

      head.textContent = 'Settings';
      body.className = 'body settings-body';
      body.innerHTML = '';

      Object.keys(metadata).forEach(groupKey => {
        const group = metadata[groupKey];
        const groupDiv = document.createElement('div');
        groupDiv.className = 'settings-group';

        const groupTitle = document.createElement('h3');
        groupTitle.textContent = group.display_name;
        groupDiv.appendChild(groupTitle);

        if (group.description) {
          const groupDesc = document.createElement('div');
          groupDesc.className = 'description';
          groupDesc.textContent = group.description;
          groupDiv.appendChild(groupDesc);
        }

        Object.keys(group.settings).forEach(settingKey => {
          const setting = group.settings[settingKey];
          const settingDiv = createSettingElement(setting, values[settingKey]);
          groupDiv.appendChild(settingDiv);
        });

        body.appendChild(groupDiv);
      });

      foot.innerHTML = '<button onclick="onCloseModal()">Cancel</button><button onclick="saveSettings()">Save</button>';
      modal.style.display = 'flex';
    }

    function createSettingElement(setting, currentValue) {
      const div = document.createElement('div');
      div.className = 'setting-item';

      const label = document.createElement('label');
      label.className = 'setting-label';
      label.textContent = setting.display_name;
      label.setAttribute('for', setting.key);
      div.appendChild(label);

      if (setting.description) {
        const desc = document.createElement('div');
        desc.className = 'setting-description';
        desc.textContent = setting.description;
        div.appendChild(desc);
      }

      const input = createInputElement(setting, currentValue);
      div.appendChild(input);

      return div;
    }

    function createInputElement(setting, currentValue) {
      const type = setting.type;
      let input;

      switch (type) {
        case 'boolean':
          input = document.createElement('input');
          input.type = 'checkbox';
          input.checked = currentValue || false;
          break;

        case 'integer':
          input = document.createElement('input');
          input.type = 'number';
          input.step = '1';
          input.value = currentValue !== null ? currentValue : setting.default_value;
          if (setting.min_value !== null) input.min = setting.min_value;
          if (setting.max_value !== null) input.max = setting.max_value;
          break;

        case 'float':
          input = document.createElement('input');
          input.type = 'number';
          input.step = setting.step || '0.1';
          input.value = currentValue !== null ? currentValue : setting.default_value;
          if (setting.min_value !== null) input.min = setting.min_value;
          if (setting.max_value !== null) input.max = setting.max_value;
          break;

        case 'slider':
          const container = document.createElement('div');
          input = document.createElement('input');
          input.type = 'range';
          input.min = setting.min_value;
          input.max = setting.max_value;
          input.step = setting.step || '1';
          input.value = currentValue !== null ? currentValue : setting.default_value;
          
          const display = document.createElement('div');
          display.className = 'range-display';
          display.textContent = input.value;

          input.addEventListener('input', () => {
            display.textContent = input.value;
          });

          container.appendChild(input);
          container.appendChild(display);
          input = container;
          break;

        default:
          input = document.createElement('input');
          input.type = 'text';
          input.value = currentValue || setting.default_value || '';
      }

      if (input.querySelector) {
        const actualInput = input.querySelector('input') || input;
        actualInput.className = 'setting-input';
        actualInput.id = setting.key;
        actualInput.dataset.settingKey = setting.key;
        actualInput.dataset.settingType = setting.type;
      } else {
        input.className = 'setting-input';
        input.id = setting.key;
        input.dataset.settingKey = setting.key;
        input.dataset.settingType = setting.type;
      }

      return input;
    }

    async function saveSettings() {
      if (!window.pywebview || !pywebview.api) {
        showMessage({message: 'Settings API not available', type: 'error'});
        return;
      }

      const settingsInputs = document.querySelectorAll('[data-setting-key]');
      let hasChanges = false;
      let hasErrors = false;

      for (const input of settingsInputs) {
        const key = input.dataset.settingKey;
        const type = input.dataset.settingType;
        let value;

        try {
          switch (type) {
            case 'boolean':
              value = input.checked;
              break;
            case 'integer':
              value = input.value === '' ? null : parseInt(input.value, 10);
              break;
            case 'float':
            case 'slider':
              value = input.value === '' ? null : parseFloat(input.value);
              break;
            default:
              value = input.value;
          }

          const success = await pywebview.api.update_setting(key, value);
          if (success) {
            hasChanges = true;
          } else {
            hasErrors = true;
            console.error(`Failed to update setting ${key} to ${value}`);
          }
        } catch (e) {
          hasErrors = true;
          console.error(`Error updating setting ${key}:`, e);
        }
      }

      if (hasErrors) {
        showMessage({message: 'Some settings could not be updated', type: 'warning'});
      }

      if (hasChanges) {
        try {
          const saveSuccess = await pywebview.api.save_settings();
          if (saveSuccess) {
            showMessage({message: 'Settings saved successfully', type: 'success'});
            onCloseModal();
          } else {
            showMessage({message: 'Failed to save settings to file', type: 'error'});
          }
        } catch (e) {
          showMessage({message: 'Error saving settings: ' + e.message, type: 'error'});
        }
      } else {
        onCloseModal();
      }
    }

    function onDelete() {
      if (state.selected < 0) { showMessage({message: 'Please select an item to delete.', type: 'warning'}); return; }
      if (!confirm('Are you sure you want to delete this item?')) return;
      if (window.pywebview && pywebview.api) pywebview.api.on_delete(state.selected);
    }

    function showContextMenu(e, index) {
      e.preventDefault();
      selectRow(index);
      
      if (contextMenu) {
        contextMenu.remove();
      }
      
      contextMenu = document.createElement('div');
      contextMenu.className = 'context-menu';
      contextMenu.innerHTML = '<div class="context-menu-item danger" onclick="onDelete(); hideContextMenu();">Delete</div>';
      
      document.body.appendChild(contextMenu);
      
      contextMenu.style.left = e.pageX + 'px';
      contextMenu.style.top = e.pageY + 'px';
      contextMenu.style.display = 'block';
      
      document.addEventListener('click', hideContextMenu, { once: true });
    }

    function hideContextMenu() {
      if (contextMenu) {
        contextMenu.remove();
        contextMenu = null;
      }
    }

    function copyFromModal() {
      if (window.pywebview && pywebview.api) pywebview.api.on_copy(state.selected);
      onCloseModal();
    }

    function showMessage(payload) {
      const msg = (payload && payload.message) ? payload.message : '';
      alert(msg);
    }

    function focusSearch() {
      const el = document.getElementById('search'); if (el) el.focus();
    }

    function checkPyWebViewAPI() {
      if (window.pywebview && pywebview.api && pywebview.api.on_ready) {
        pywebview.api.on_ready();
        return true;
      }
      return false;
    }

    window.addEventListener('DOMContentLoaded', () => {
      document.getElementById('search').addEventListener('input', onSearch);
      document.getElementById('copy').addEventListener('click', onCopy);
      document.getElementById('view').addEventListener('click', onView);
      document.getElementById('clear').addEventListener('click', onClear);
      document.getElementById('settings').addEventListener('click', onSettings);
      document.getElementById('close-modal').addEventListener('click', onCloseModal);
      document.getElementById('copy-modal').addEventListener('click', copyFromModal);
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Delete' && state.selected >= 0) {
          onDelete();
        }
      });

      focusSearch();

      if (!checkPyWebViewAPI()) {
        setTimeout(() => {
          if (!checkPyWebViewAPI()) {
            setTimeout(checkPyWebViewAPI, 500);
          }
        }, 100);
      }
    });
  </script>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div>🔍</div>
      <input id="search" type="text" placeholder="Search..." />
      <button id="settings">⚙️</button>
    </div>
    <div class="content">
      <table>
        <thead><tr><th>#</th><th>Content</th></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <div class="buttons">
      <div class="left">
        <button id="copy">Copy Selected</button>
        <button id="view">View Full Text</button>
      </div>
      <div class="right">
        <button id="clear">Clear History</button>
      </div>
    </div>
  </div>

  <div id="modal" class="modal">
    <div class="card">
      <div class="head">Full Text</div>
      <div id="modal-text" class="body"></div>
      <div class="foot">
        <button id="close-modal">Close</button>
        <button id="copy-modal">Copy to Clipboard</button>
      </div>
    </div>
  </div>
</body>
</html>

